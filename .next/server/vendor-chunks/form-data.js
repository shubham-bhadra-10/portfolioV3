/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data";
exports.ids = ["vendor-chunks/form-data"];
exports.modules = {

/***/ "(ssr)/./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(ssr)/./node_modules/combined-stream/lib/combined_stream.js\");\r\nvar util = __webpack_require__(/*! util */ \"util\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\r\nvar mime = __webpack_require__(/*! mime-types */ \"(ssr)/./node_modules/mime-types/index.js\");\r\nvar asynckit = __webpack_require__(/*! asynckit */ \"(ssr)/./node_modules/asynckit/index.js\");\r\nvar populate = __webpack_require__(/*! ./populate.js */ \"(ssr)/./node_modules/form-data/lib/populate.js\");\r\n\r\n// Public API\r\nmodule.exports = FormData;\r\n\r\n// make it a Stream\r\nutil.inherits(FormData, CombinedStream);\r\n\r\n/**\r\n * Create readable \"multipart/form-data\" streams.\r\n * Can be used to submit forms\r\n * and file uploads to other web applications.\r\n *\r\n * @constructor\r\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\r\n */\r\nfunction FormData(options) {\r\n  if (!(this instanceof FormData)) {\r\n    return new FormData(options);\r\n  }\r\n\r\n  this._overheadLength = 0;\r\n  this._valueLength = 0;\r\n  this._valuesToMeasure = [];\r\n\r\n  CombinedStream.call(this);\r\n\r\n  options = options || {};\r\n  for (var option in options) {\r\n    this[option] = options[option];\r\n  }\r\n}\r\n\r\nFormData.LINE_BREAK = '\\r\\n';\r\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\r\n\r\nFormData.prototype.append = function(field, value, options) {\r\n\r\n  options = options || {};\r\n\r\n  // allow filename as single option\r\n  if (typeof options == 'string') {\r\n    options = {filename: options};\r\n  }\r\n\r\n  var append = CombinedStream.prototype.append.bind(this);\r\n\r\n  // all that streamy business can't handle numbers\r\n  if (typeof value == 'number') {\r\n    value = '' + value;\r\n  }\r\n\r\n  // https://github.com/felixge/node-form-data/issues/38\r\n  if (util.isArray(value)) {\r\n    // Please convert your array into string\r\n    // the way web server expects it\r\n    this._error(new Error('Arrays are not supported.'));\r\n    return;\r\n  }\r\n\r\n  var header = this._multiPartHeader(field, value, options);\r\n  var footer = this._multiPartFooter();\r\n\r\n  append(header);\r\n  append(value);\r\n  append(footer);\r\n\r\n  // pass along options.knownLength\r\n  this._trackLength(header, value, options);\r\n};\r\n\r\nFormData.prototype._trackLength = function(header, value, options) {\r\n  var valueLength = 0;\r\n\r\n  // used w/ getLengthSync(), when length is known.\r\n  // e.g. for streaming directly from a remote server,\r\n  // w/ a known file a size, and not wanting to wait for\r\n  // incoming file to finish to get its size.\r\n  if (options.knownLength != null) {\r\n    valueLength += +options.knownLength;\r\n  } else if (Buffer.isBuffer(value)) {\r\n    valueLength = value.length;\r\n  } else if (typeof value === 'string') {\r\n    valueLength = Buffer.byteLength(value);\r\n  }\r\n\r\n  this._valueLength += valueLength;\r\n\r\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\r\n  this._overheadLength +=\r\n    Buffer.byteLength(header) +\r\n    FormData.LINE_BREAK.length;\r\n\r\n  // empty or either doesn't have path or not an http response or not a stream\r\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {\r\n    return;\r\n  }\r\n\r\n  // no need to bother with the length\r\n  if (!options.knownLength) {\r\n    this._valuesToMeasure.push(value);\r\n  }\r\n};\r\n\r\nFormData.prototype._lengthRetriever = function(value, callback) {\r\n\r\n  if (value.hasOwnProperty('fd')) {\r\n\r\n    // take read range into a account\r\n    // `end` = Infinity â€“> read file till the end\r\n    //\r\n    // TODO: Looks like there is bug in Node fs.createReadStream\r\n    // it doesn't respect `end` options without `start` options\r\n    // Fix it when node fixes it.\r\n    // https://github.com/joyent/node/issues/7819\r\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\r\n\r\n      // when end specified\r\n      // no need to calculate range\r\n      // inclusive, starts with 0\r\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\r\n\r\n    // not that fast snoopy\r\n    } else {\r\n      // still need to fetch file size from fs\r\n      fs.stat(value.path, function(err, stat) {\r\n\r\n        var fileSize;\r\n\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        // update final size based on the range options\r\n        fileSize = stat.size - (value.start ? value.start : 0);\r\n        callback(null, fileSize);\r\n      });\r\n    }\r\n\r\n  // or http response\r\n  } else if (value.hasOwnProperty('httpVersion')) {\r\n    callback(null, +value.headers['content-length']);\r\n\r\n  // or request stream http://github.com/mikeal/request\r\n  } else if (value.hasOwnProperty('httpModule')) {\r\n    // wait till response come back\r\n    value.on('response', function(response) {\r\n      value.pause();\r\n      callback(null, +response.headers['content-length']);\r\n    });\r\n    value.resume();\r\n\r\n  // something else\r\n  } else {\r\n    callback('Unknown stream');\r\n  }\r\n};\r\n\r\nFormData.prototype._multiPartHeader = function(field, value, options) {\r\n  // custom header specified (as string)?\r\n  // it becomes responsible for boundary\r\n  // (e.g. to handle extra CRLFs on .NET servers)\r\n  if (typeof options.header == 'string') {\r\n    return options.header;\r\n  }\r\n\r\n  var contentDisposition = this._getContentDisposition(value, options);\r\n  var contentType = this._getContentType(value, options);\r\n\r\n  var contents = '';\r\n  var headers  = {\r\n    // add custom disposition as third element or keep it two elements if not\r\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\r\n    // if no content type. allow it to be empty array\r\n    'Content-Type': [].concat(contentType || [])\r\n  };\r\n\r\n  // allow custom headers.\r\n  if (typeof options.header == 'object') {\r\n    populate(headers, options.header);\r\n  }\r\n\r\n  var header;\r\n  for (var prop in headers) {\r\n    if (!headers.hasOwnProperty(prop)) continue;\r\n    header = headers[prop];\r\n\r\n    // skip nullish headers.\r\n    if (header == null) {\r\n      continue;\r\n    }\r\n\r\n    // convert all headers to arrays.\r\n    if (!Array.isArray(header)) {\r\n      header = [header];\r\n    }\r\n\r\n    // add non-empty headers.\r\n    if (header.length) {\r\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\r\n    }\r\n  }\r\n\r\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\r\n};\r\n\r\nFormData.prototype._getContentDisposition = function(value, options) {\r\n\r\n  var filename\r\n    , contentDisposition\r\n    ;\r\n\r\n  if (typeof options.filepath === 'string') {\r\n    // custom filepath for relative paths\r\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\r\n  } else if (options.filename || value.name || value.path) {\r\n    // custom filename take precedence\r\n    // formidable and the browser add a name property\r\n    // fs- and request- streams have path property\r\n    filename = path.basename(options.filename || value.name || value.path);\r\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\r\n    // or try http response\r\n    filename = path.basename(value.client._httpMessage.path || '');\r\n  }\r\n\r\n  if (filename) {\r\n    contentDisposition = 'filename=\"' + filename + '\"';\r\n  }\r\n\r\n  return contentDisposition;\r\n};\r\n\r\nFormData.prototype._getContentType = function(value, options) {\r\n\r\n  // use custom content-type above all\r\n  var contentType = options.contentType;\r\n\r\n  // or try `name` from formidable, browser\r\n  if (!contentType && value.name) {\r\n    contentType = mime.lookup(value.name);\r\n  }\r\n\r\n  // or try `path` from fs-, request- streams\r\n  if (!contentType && value.path) {\r\n    contentType = mime.lookup(value.path);\r\n  }\r\n\r\n  // or if it's http-reponse\r\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\r\n    contentType = value.headers['content-type'];\r\n  }\r\n\r\n  // or guess it from the filepath or filename\r\n  if (!contentType && (options.filepath || options.filename)) {\r\n    contentType = mime.lookup(options.filepath || options.filename);\r\n  }\r\n\r\n  // fallback to the default content type if `value` is not simple value\r\n  if (!contentType && typeof value == 'object') {\r\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\r\n  }\r\n\r\n  return contentType;\r\n};\r\n\r\nFormData.prototype._multiPartFooter = function() {\r\n  return function(next) {\r\n    var footer = FormData.LINE_BREAK;\r\n\r\n    var lastPart = (this._streams.length === 0);\r\n    if (lastPart) {\r\n      footer += this._lastBoundary();\r\n    }\r\n\r\n    next(footer);\r\n  }.bind(this);\r\n};\r\n\r\nFormData.prototype._lastBoundary = function() {\r\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\r\n};\r\n\r\nFormData.prototype.getHeaders = function(userHeaders) {\r\n  var header;\r\n  var formHeaders = {\r\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\r\n  };\r\n\r\n  for (header in userHeaders) {\r\n    if (userHeaders.hasOwnProperty(header)) {\r\n      formHeaders[header.toLowerCase()] = userHeaders[header];\r\n    }\r\n  }\r\n\r\n  return formHeaders;\r\n};\r\n\r\nFormData.prototype.setBoundary = function(boundary) {\r\n  this._boundary = boundary;\r\n};\r\n\r\nFormData.prototype.getBoundary = function() {\r\n  if (!this._boundary) {\r\n    this._generateBoundary();\r\n  }\r\n\r\n  return this._boundary;\r\n};\r\n\r\nFormData.prototype.getBuffer = function() {\r\n  var dataBuffer = new Buffer.alloc( 0 );\r\n  var boundary = this.getBoundary();\r\n\r\n  // Create the form content. Add Line breaks to the end of data.\r\n  for (var i = 0, len = this._streams.length; i < len; i++) {\r\n    if (typeof this._streams[i] !== 'function') {\r\n\r\n      // Add content to the buffer.\r\n      if(Buffer.isBuffer(this._streams[i])) {\r\n        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);\r\n      }else {\r\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);\r\n      }\r\n\r\n      // Add break after content.\r\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {\r\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add the footer and return the Buffer object.\r\n  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );\r\n};\r\n\r\nFormData.prototype._generateBoundary = function() {\r\n  // This generates a 50 character boundary similar to those used by Firefox.\r\n  // They are optimized for boyer-moore parsing.\r\n  var boundary = '--------------------------';\r\n  for (var i = 0; i < 24; i++) {\r\n    boundary += Math.floor(Math.random() * 10).toString(16);\r\n  }\r\n\r\n  this._boundary = boundary;\r\n};\r\n\r\n// Note: getLengthSync DOESN'T calculate streams length\r\n// As workaround one can calculate file size manually\r\n// and add it as knownLength option\r\nFormData.prototype.getLengthSync = function() {\r\n  var knownLength = this._overheadLength + this._valueLength;\r\n\r\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\r\n  // so it basically checks if there is any value added to the form\r\n  if (this._streams.length) {\r\n    knownLength += this._lastBoundary().length;\r\n  }\r\n\r\n  // https://github.com/form-data/form-data/issues/40\r\n  if (!this.hasKnownLength()) {\r\n    // Some async length retrievers are present\r\n    // therefore synchronous length calculation is false.\r\n    // Please use getLength(callback) to get proper length\r\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\r\n  }\r\n\r\n  return knownLength;\r\n};\r\n\r\n// Public API to check if length of added values is known\r\n// https://github.com/form-data/form-data/issues/196\r\n// https://github.com/form-data/form-data/issues/262\r\nFormData.prototype.hasKnownLength = function() {\r\n  var hasKnownLength = true;\r\n\r\n  if (this._valuesToMeasure.length) {\r\n    hasKnownLength = false;\r\n  }\r\n\r\n  return hasKnownLength;\r\n};\r\n\r\nFormData.prototype.getLength = function(cb) {\r\n  var knownLength = this._overheadLength + this._valueLength;\r\n\r\n  if (this._streams.length) {\r\n    knownLength += this._lastBoundary().length;\r\n  }\r\n\r\n  if (!this._valuesToMeasure.length) {\r\n    process.nextTick(cb.bind(this, null, knownLength));\r\n    return;\r\n  }\r\n\r\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\r\n    if (err) {\r\n      cb(err);\r\n      return;\r\n    }\r\n\r\n    values.forEach(function(length) {\r\n      knownLength += length;\r\n    });\r\n\r\n    cb(null, knownLength);\r\n  });\r\n};\r\n\r\nFormData.prototype.submit = function(params, cb) {\r\n  var request\r\n    , options\r\n    , defaults = {method: 'post'}\r\n    ;\r\n\r\n  // parse provided url if it's string\r\n  // or treat it as options object\r\n  if (typeof params == 'string') {\r\n\r\n    params = parseUrl(params);\r\n    options = populate({\r\n      port: params.port,\r\n      path: params.pathname,\r\n      host: params.hostname,\r\n      protocol: params.protocol\r\n    }, defaults);\r\n\r\n  // use custom params\r\n  } else {\r\n\r\n    options = populate(params, defaults);\r\n    // if no port provided use default one\r\n    if (!options.port) {\r\n      options.port = options.protocol == 'https:' ? 443 : 80;\r\n    }\r\n  }\r\n\r\n  // put that good code in getHeaders to some use\r\n  options.headers = this.getHeaders(params.headers);\r\n\r\n  // https if specified, fallback to http in any other case\r\n  if (options.protocol == 'https:') {\r\n    request = https.request(options);\r\n  } else {\r\n    request = http.request(options);\r\n  }\r\n\r\n  // get content length and fire away\r\n  this.getLength(function(err, length) {\r\n    if (err && err !== 'Unknown stream') {\r\n      this._error(err);\r\n      return;\r\n    }\r\n\r\n    // add content length\r\n    if (length) {\r\n      request.setHeader('Content-Length', length);\r\n    }\r\n\r\n    this.pipe(request);\r\n    if (cb) {\r\n      var onResponse;\r\n\r\n      var callback = function (error, responce) {\r\n        request.removeListener('error', callback);\r\n        request.removeListener('response', onResponse);\r\n\r\n        return cb.call(this, error, responce);\r\n      };\r\n\r\n      onResponse = callback.bind(this, null);\r\n\r\n      request.on('error', callback);\r\n      request.on('response', onResponse);\r\n    }\r\n  }.bind(this));\r\n\r\n  return request;\r\n};\r\n\r\nFormData.prototype._error = function(err) {\r\n  if (!this.error) {\r\n    this.error = err;\r\n    this.pause();\r\n    this.emit('error', err);\r\n  }\r\n};\r\n\r\nFormData.prototype.toString = function () {\r\n  return '[object FormData]';\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQzlDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixlQUFlLDZDQUFvQjtBQUNuQyxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixhQUFhLG9EQUF3QjtBQUNyQyxXQUFXLG1CQUFPLENBQUMsNERBQVk7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RldmVsb3Blci1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanM/NWE5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcclxudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XHJcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XHJcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpO1xyXG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xyXG52YXIgcG9wdWxhdGUgPSByZXF1aXJlKCcuL3BvcHVsYXRlLmpzJyk7XHJcblxyXG4vLyBQdWJsaWMgQVBJXHJcbm1vZHVsZS5leHBvcnRzID0gRm9ybURhdGE7XHJcblxyXG4vLyBtYWtlIGl0IGEgU3RyZWFtXHJcbnV0aWwuaW5oZXJpdHMoRm9ybURhdGEsIENvbWJpbmVkU3RyZWFtKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgcmVhZGFibGUgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgc3RyZWFtcy5cclxuICogQ2FuIGJlIHVzZWQgdG8gc3VibWl0IGZvcm1zXHJcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxyXG4gKi9cclxuZnVuY3Rpb24gRm9ybURhdGEob3B0aW9ucykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcclxuICAgIHJldHVybiBuZXcgRm9ybURhdGEob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLl9vdmVyaGVhZExlbmd0aCA9IDA7XHJcbiAgdGhpcy5fdmFsdWVMZW5ndGggPSAwO1xyXG4gIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSA9IFtdO1xyXG5cclxuICBDb21iaW5lZFN0cmVhbS5jYWxsKHRoaXMpO1xyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xyXG4gICAgdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xyXG4gIH1cclxufVxyXG5cclxuRm9ybURhdGEuTElORV9CUkVBSyA9ICdcXHJcXG4nO1xyXG5Gb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsb3cgZmlsZW5hbWUgYXMgc2luZ2xlIG9wdGlvblxyXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xyXG4gICAgb3B0aW9ucyA9IHtmaWxlbmFtZTogb3B0aW9uc307XHJcbiAgfVxyXG5cclxuICB2YXIgYXBwZW5kID0gQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZC5iaW5kKHRoaXMpO1xyXG5cclxuICAvLyBhbGwgdGhhdCBzdHJlYW15IGJ1c2luZXNzIGNhbid0IGhhbmRsZSBudW1iZXJzXHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xyXG4gICAgdmFsdWUgPSAnJyArIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZlbGl4Z2Uvbm9kZS1mb3JtLWRhdGEvaXNzdWVzLzM4XHJcbiAgaWYgKHV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIC8vIFBsZWFzZSBjb252ZXJ0IHlvdXIgYXJyYXkgaW50byBzdHJpbmdcclxuICAgIC8vIHRoZSB3YXkgd2ViIHNlcnZlciBleHBlY3RzIGl0XHJcbiAgICB0aGlzLl9lcnJvcihuZXcgRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZC4nKSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgaGVhZGVyID0gdGhpcy5fbXVsdGlQYXJ0SGVhZGVyKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgdmFyIGZvb3RlciA9IHRoaXMuX211bHRpUGFydEZvb3RlcigpO1xyXG5cclxuICBhcHBlbmQoaGVhZGVyKTtcclxuICBhcHBlbmQodmFsdWUpO1xyXG4gIGFwcGVuZChmb290ZXIpO1xyXG5cclxuICAvLyBwYXNzIGFsb25nIG9wdGlvbnMua25vd25MZW5ndGhcclxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgdmFyIHZhbHVlTGVuZ3RoID0gMDtcclxuXHJcbiAgLy8gdXNlZCB3LyBnZXRMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxyXG4gIC8vIGUuZy4gZm9yIHN0cmVhbWluZyBkaXJlY3RseSBmcm9tIGEgcmVtb3RlIHNlcnZlcixcclxuICAvLyB3LyBhIGtub3duIGZpbGUgYSBzaXplLCBhbmQgbm90IHdhbnRpbmcgdG8gd2FpdCBmb3JcclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXHJcbiAgaWYgKG9wdGlvbnMua25vd25MZW5ndGggIT0gbnVsbCkge1xyXG4gICAgdmFsdWVMZW5ndGggKz0gK29wdGlvbnMua25vd25MZW5ndGg7XHJcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XHJcbiAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XHJcblxyXG4gIC8vIEBjaGVjayB3aHkgYWRkIENSTEY/IGRvZXMgdGhpcyBhY2NvdW50IGZvciBjdXN0b20vbXVsdGlwbGUgQ1JMRnM/XHJcbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cclxuICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGhlYWRlcikgK1xyXG4gICAgRm9ybURhdGEuTElORV9CUkVBSy5sZW5ndGg7XHJcblxyXG4gIC8vIGVtcHR5IG9yIGVpdGhlciBkb2Vzbid0IGhhdmUgcGF0aCBvciBub3QgYW4gaHR0cCByZXNwb25zZSBvciBub3QgYSBzdHJlYW1cclxuICBpZiAoIXZhbHVlIHx8ICggIXZhbHVlLnBhdGggJiYgISh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmVhbSkpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBubyBuZWVkIHRvIGJvdGhlciB3aXRoIHRoZSBsZW5ndGhcclxuICBpZiAoIW9wdGlvbnMua25vd25MZW5ndGgpIHtcclxuICAgIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5wdXNoKHZhbHVlKTtcclxuICB9XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xlbmd0aFJldHJpZXZlciA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaykge1xyXG5cclxuICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2ZkJykpIHtcclxuXHJcbiAgICAvLyB0YWtlIHJlYWQgcmFuZ2UgaW50byBhIGFjY291bnRcclxuICAgIC8vIGBlbmRgID0gSW5maW5pdHkg4oCTPiByZWFkIGZpbGUgdGlsbCB0aGUgZW5kXHJcbiAgICAvL1xyXG4gICAgLy8gVE9ETzogTG9va3MgbGlrZSB0aGVyZSBpcyBidWcgaW4gTm9kZSBmcy5jcmVhdGVSZWFkU3RyZWFtXHJcbiAgICAvLyBpdCBkb2Vzbid0IHJlc3BlY3QgYGVuZGAgb3B0aW9ucyB3aXRob3V0IGBzdGFydGAgb3B0aW9uc1xyXG4gICAgLy8gRml4IGl0IHdoZW4gbm9kZSBmaXhlcyBpdC5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNzgxOVxyXG4gICAgaWYgKHZhbHVlLmVuZCAhPSB1bmRlZmluZWQgJiYgdmFsdWUuZW5kICE9IEluZmluaXR5ICYmIHZhbHVlLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgLy8gd2hlbiBlbmQgc3BlY2lmaWVkXHJcbiAgICAgIC8vIG5vIG5lZWQgdG8gY2FsY3VsYXRlIHJhbmdlXHJcbiAgICAgIC8vIGluY2x1c2l2ZSwgc3RhcnRzIHdpdGggMFxyXG4gICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZS5lbmQgKyAxIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKSk7XHJcblxyXG4gICAgLy8gbm90IHRoYXQgZmFzdCBzbm9vcHlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHN0aWxsIG5lZWQgdG8gZmV0Y2ggZmlsZSBzaXplIGZyb20gZnNcclxuICAgICAgZnMuc3RhdCh2YWx1ZS5wYXRoLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGZpbGVTaXplO1xyXG5cclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGZpbmFsIHNpemUgYmFzZWQgb24gdGhlIHJhbmdlIG9wdGlvbnNcclxuICAgICAgICBmaWxlU2l6ZSA9IHN0YXQuc2l6ZSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCk7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZVNpemUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgLy8gb3IgaHR0cCByZXNwb25zZVxyXG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcclxuICAgIGNhbGxiYWNrKG51bGwsICt2YWx1ZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcclxuXHJcbiAgLy8gb3IgcmVxdWVzdCBzdHJlYW0gaHR0cDovL2dpdGh1Yi5jb20vbWlrZWFsL3JlcXVlc3RcclxuICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwTW9kdWxlJykpIHtcclxuICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcclxuICAgIHZhbHVlLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgIHZhbHVlLnBhdXNlKCk7XHJcbiAgICAgIGNhbGxiYWNrKG51bGwsICtyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcclxuICAgIH0pO1xyXG4gICAgdmFsdWUucmVzdW1lKCk7XHJcblxyXG4gIC8vIHNvbWV0aGluZyBlbHNlXHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbGxiYWNrKCdVbmtub3duIHN0cmVhbScpO1xyXG4gIH1cclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0SGVhZGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgLy8gY3VzdG9tIGhlYWRlciBzcGVjaWZpZWQgKGFzIHN0cmluZyk/XHJcbiAgLy8gaXQgYmVjb21lcyByZXNwb25zaWJsZSBmb3IgYm91bmRhcnlcclxuICAvLyAoZS5nLiB0byBoYW5kbGUgZXh0cmEgQ1JMRnMgb24gLk5FVCBzZXJ2ZXJzKVxyXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBvcHRpb25zLmhlYWRlcjtcclxuICB9XHJcblxyXG4gIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50RGlzcG9zaXRpb24odmFsdWUsIG9wdGlvbnMpO1xyXG4gIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2dldENvbnRlbnRUeXBlKHZhbHVlLCBvcHRpb25zKTtcclxuXHJcbiAgdmFyIGNvbnRlbnRzID0gJyc7XHJcbiAgdmFyIGhlYWRlcnMgID0ge1xyXG4gICAgLy8gYWRkIGN1c3RvbSBkaXNwb3NpdGlvbiBhcyB0aGlyZCBlbGVtZW50IG9yIGtlZXAgaXQgdHdvIGVsZW1lbnRzIGlmIG5vdFxyXG4gICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBbJ2Zvcm0tZGF0YScsICduYW1lPVwiJyArIGZpZWxkICsgJ1wiJ10uY29uY2F0KGNvbnRlbnREaXNwb3NpdGlvbiB8fCBbXSksXHJcbiAgICAvLyBpZiBubyBjb250ZW50IHR5cGUuIGFsbG93IGl0IHRvIGJlIGVtcHR5IGFycmF5XHJcbiAgICAnQ29udGVudC1UeXBlJzogW10uY29uY2F0KGNvbnRlbnRUeXBlIHx8IFtdKVxyXG4gIH07XHJcblxyXG4gIC8vIGFsbG93IGN1c3RvbSBoZWFkZXJzLlxyXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ29iamVjdCcpIHtcclxuICAgIHBvcHVsYXRlKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVyKTtcclxuICB9XHJcblxyXG4gIHZhciBoZWFkZXI7XHJcbiAgZm9yICh2YXIgcHJvcCBpbiBoZWFkZXJzKSB7XHJcbiAgICBpZiAoIWhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xyXG4gICAgaGVhZGVyID0gaGVhZGVyc1twcm9wXTtcclxuXHJcbiAgICAvLyBza2lwIG51bGxpc2ggaGVhZGVycy5cclxuICAgIGlmIChoZWFkZXIgPT0gbnVsbCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb252ZXJ0IGFsbCBoZWFkZXJzIHRvIGFycmF5cy5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpKSB7XHJcbiAgICAgIGhlYWRlciA9IFtoZWFkZXJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBub24tZW1wdHkgaGVhZGVycy5cclxuICAgIGlmIChoZWFkZXIubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnRlbnRzICs9IHByb3AgKyAnOiAnICsgaGVhZGVyLmpvaW4oJzsgJykgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICsgY29udGVudHMgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICB2YXIgZmlsZW5hbWVcclxuICAgICwgY29udGVudERpc3Bvc2l0aW9uXHJcbiAgICA7XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxlcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgIC8vIGN1c3RvbSBmaWxlcGF0aCBmb3IgcmVsYXRpdmUgcGF0aHNcclxuICAgIGZpbGVuYW1lID0gcGF0aC5ub3JtYWxpemUob3B0aW9ucy5maWxlcGF0aCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpIHtcclxuICAgIC8vIGN1c3RvbSBmaWxlbmFtZSB0YWtlIHByZWNlZGVuY2VcclxuICAgIC8vIGZvcm1pZGFibGUgYW5kIHRoZSBicm93c2VyIGFkZCBhIG5hbWUgcHJvcGVydHlcclxuICAgIC8vIGZzLSBhbmQgcmVxdWVzdC0gc3RyZWFtcyBoYXZlIHBhdGggcHJvcGVydHlcclxuICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZShvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLm5hbWUgfHwgdmFsdWUucGF0aCk7XHJcbiAgfSBlbHNlIGlmICh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xyXG4gICAgLy8gb3IgdHJ5IGh0dHAgcmVzcG9uc2VcclxuICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh2YWx1ZS5jbGllbnQuX2h0dHBNZXNzYWdlLnBhdGggfHwgJycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZpbGVuYW1lKSB7XHJcbiAgICBjb250ZW50RGlzcG9zaXRpb24gPSAnZmlsZW5hbWU9XCInICsgZmlsZW5hbWUgKyAnXCInO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnRlbnREaXNwb3NpdGlvbjtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICAvLyB1c2UgY3VzdG9tIGNvbnRlbnQtdHlwZSBhYm92ZSBhbGxcclxuICB2YXIgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xyXG5cclxuICAvLyBvciB0cnkgYG5hbWVgIGZyb20gZm9ybWlkYWJsZSwgYnJvd3NlclxyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUubmFtZSkge1xyXG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5uYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIG9yIHRyeSBgcGF0aGAgZnJvbSBmcy0sIHJlcXVlc3QtIHN0cmVhbXNcclxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnBhdGgpIHtcclxuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUucGF0aCk7XHJcbiAgfVxyXG5cclxuICAvLyBvciBpZiBpdCdzIGh0dHAtcmVwb25zZVxyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucmVhZGFibGUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcclxuICAgIGNvbnRlbnRUeXBlID0gdmFsdWUuaGVhZGVyc1snY29udGVudC10eXBlJ107XHJcbiAgfVxyXG5cclxuICAvLyBvciBndWVzcyBpdCBmcm9tIHRoZSBmaWxlcGF0aCBvciBmaWxlbmFtZVxyXG4gIGlmICghY29udGVudFR5cGUgJiYgKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSkpIHtcclxuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpZiBgdmFsdWVgIGlzIG5vdCBzaW1wbGUgdmFsdWVcclxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xyXG4gICAgY29udGVudFR5cGUgPSBGb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb250ZW50VHlwZTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKG5leHQpIHtcclxuICAgIHZhciBmb290ZXIgPSBGb3JtRGF0YS5MSU5FX0JSRUFLO1xyXG5cclxuICAgIHZhciBsYXN0UGFydCA9ICh0aGlzLl9zdHJlYW1zLmxlbmd0aCA9PT0gMCk7XHJcbiAgICBpZiAobGFzdFBhcnQpIHtcclxuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG5leHQoZm9vdGVyKTtcclxuICB9LmJpbmQodGhpcyk7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xhc3RCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgJy0tJyArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0SGVhZGVycyA9IGZ1bmN0aW9uKHVzZXJIZWFkZXJzKSB7XHJcbiAgdmFyIGhlYWRlcjtcclxuICB2YXIgZm9ybUhlYWRlcnMgPSB7XHJcbiAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PScgKyB0aGlzLmdldEJvdW5kYXJ5KClcclxuICB9O1xyXG5cclxuICBmb3IgKGhlYWRlciBpbiB1c2VySGVhZGVycykge1xyXG4gICAgaWYgKHVzZXJIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcclxuICAgICAgZm9ybUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdXNlckhlYWRlcnNbaGVhZGVyXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmb3JtSGVhZGVycztcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5zZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKGJvdW5kYXJ5KSB7XHJcbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmICghdGhpcy5fYm91bmRhcnkpIHtcclxuICAgIHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLl9ib3VuZGFyeTtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIuYWxsb2MoIDAgKTtcclxuICB2YXIgYm91bmRhcnkgPSB0aGlzLmdldEJvdW5kYXJ5KCk7XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgZm9ybSBjb250ZW50LiBBZGQgTGluZSBicmVha3MgdG8gdGhlIGVuZCBvZiBkYXRhLlxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9zdHJlYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0cmVhbXNbaV0gIT09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgIC8vIEFkZCBjb250ZW50IHRvIHRoZSBidWZmZXIuXHJcbiAgICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9zdHJlYW1zW2ldKSkge1xyXG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgdGhpcy5fc3RyZWFtc1tpXV0pO1xyXG4gICAgICB9ZWxzZSB7XHJcbiAgICAgICAgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCBCdWZmZXIuZnJvbSh0aGlzLl9zdHJlYW1zW2ldKV0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgYnJlYWsgYWZ0ZXIgY29udGVudC5cclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJlYW1zW2ldICE9PSAnc3RyaW5nJyB8fCB0aGlzLl9zdHJlYW1zW2ldLnN1YnN0cmluZyggMiwgYm91bmRhcnkubGVuZ3RoICsgMiApICE9PSBib3VuZGFyeSkge1xyXG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgQnVmZmVyLmZyb20oRm9ybURhdGEuTElORV9CUkVBSyldICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCB0aGUgZm9vdGVyIGFuZCByZXR1cm4gdGhlIEJ1ZmZlciBvYmplY3QuXHJcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCBCdWZmZXIuZnJvbSh0aGlzLl9sYXN0Qm91bmRhcnkoKSldICk7XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dlbmVyYXRlQm91bmRhcnkgPSBmdW5jdGlvbigpIHtcclxuICAvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvIHRob3NlIHVzZWQgYnkgRmlyZWZveC5cclxuICAvLyBUaGV5IGFyZSBvcHRpbWl6ZWQgZm9yIGJveWVyLW1vb3JlIHBhcnNpbmcuXHJcbiAgdmFyIGJvdW5kYXJ5ID0gJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJztcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcclxuICAgIGJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XHJcbiAgfVxyXG5cclxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xyXG59O1xyXG5cclxuLy8gTm90ZTogZ2V0TGVuZ3RoU3luYyBET0VTTidUIGNhbGN1bGF0ZSBzdHJlYW1zIGxlbmd0aFxyXG4vLyBBcyB3b3JrYXJvdW5kIG9uZSBjYW4gY2FsY3VsYXRlIGZpbGUgc2l6ZSBtYW51YWxseVxyXG4vLyBhbmQgYWRkIGl0IGFzIGtub3duTGVuZ3RoIG9wdGlvblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XHJcblxyXG4gIC8vIERvbid0IGdldCBjb25mdXNlZCwgdGhlcmUgYXJlIDMgXCJpbnRlcm5hbFwiIHN0cmVhbXMgZm9yIGVhY2gga2V5dmFsIHBhaXJcclxuICAvLyBzbyBpdCBiYXNpY2FsbHkgY2hlY2tzIGlmIHRoZXJlIGlzIGFueSB2YWx1ZSBhZGRlZCB0byB0aGUgZm9ybVxyXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xyXG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzQwXHJcbiAgaWYgKCF0aGlzLmhhc0tub3duTGVuZ3RoKCkpIHtcclxuICAgIC8vIFNvbWUgYXN5bmMgbGVuZ3RoIHJldHJpZXZlcnMgYXJlIHByZXNlbnRcclxuICAgIC8vIHRoZXJlZm9yZSBzeW5jaHJvbm91cyBsZW5ndGggY2FsY3VsYXRpb24gaXMgZmFsc2UuXHJcbiAgICAvLyBQbGVhc2UgdXNlIGdldExlbmd0aChjYWxsYmFjaykgdG8gZ2V0IHByb3BlciBsZW5ndGhcclxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBwcm9wZXIgbGVuZ3RoIGluIHN5bmNocm9ub3VzIHdheS4nKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ga25vd25MZW5ndGg7XHJcbn07XHJcblxyXG4vLyBQdWJsaWMgQVBJIHRvIGNoZWNrIGlmIGxlbmd0aCBvZiBhZGRlZCB2YWx1ZXMgaXMga25vd25cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzE5NlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybS1kYXRhL2Zvcm0tZGF0YS9pc3N1ZXMvMjYyXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5oYXNLbm93bkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBoYXNLbm93bkxlbmd0aCA9IHRydWU7XHJcblxyXG4gIGlmICh0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XHJcbiAgICBoYXNLbm93bkxlbmd0aCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGhhc0tub3duTGVuZ3RoO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XHJcbiAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcclxuXHJcbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XHJcbiAgICBrbm93bkxlbmd0aCArPSB0aGlzLl9sYXN0Qm91bmRhcnkoKS5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBpZiAoIXRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcclxuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZCh0aGlzLCBudWxsLCBrbm93bkxlbmd0aCkpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgYXN5bmNraXQucGFyYWxsZWwodGhpcy5fdmFsdWVzVG9NZWFzdXJlLCB0aGlzLl9sZW5ndGhSZXRyaWV2ZXIsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIGNiKGVycik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgICAga25vd25MZW5ndGggKz0gbGVuZ3RoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY2IobnVsbCwga25vd25MZW5ndGgpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuRm9ybURhdGEucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcclxuICB2YXIgcmVxdWVzdFxyXG4gICAgLCBvcHRpb25zXHJcbiAgICAsIGRlZmF1bHRzID0ge21ldGhvZDogJ3Bvc3QnfVxyXG4gICAgO1xyXG5cclxuICAvLyBwYXJzZSBwcm92aWRlZCB1cmwgaWYgaXQncyBzdHJpbmdcclxuICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxyXG4gIGlmICh0eXBlb2YgcGFyYW1zID09ICdzdHJpbmcnKSB7XHJcblxyXG4gICAgcGFyYW1zID0gcGFyc2VVcmwocGFyYW1zKTtcclxuICAgIG9wdGlvbnMgPSBwb3B1bGF0ZSh7XHJcbiAgICAgIHBvcnQ6IHBhcmFtcy5wb3J0LFxyXG4gICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXHJcbiAgICAgIGhvc3Q6IHBhcmFtcy5ob3N0bmFtZSxcclxuICAgICAgcHJvdG9jb2w6IHBhcmFtcy5wcm90b2NvbFxyXG4gICAgfSwgZGVmYXVsdHMpO1xyXG5cclxuICAvLyB1c2UgY3VzdG9tIHBhcmFtc1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHBhcmFtcywgZGVmYXVsdHMpO1xyXG4gICAgLy8gaWYgbm8gcG9ydCBwcm92aWRlZCB1c2UgZGVmYXVsdCBvbmVcclxuICAgIGlmICghb3B0aW9ucy5wb3J0KSB7XHJcbiAgICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHB1dCB0aGF0IGdvb2QgY29kZSBpbiBnZXRIZWFkZXJzIHRvIHNvbWUgdXNlXHJcbiAgb3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKHBhcmFtcy5oZWFkZXJzKTtcclxuXHJcbiAgLy8gaHR0cHMgaWYgc3BlY2lmaWVkLCBmYWxsYmFjayB0byBodHRwIGluIGFueSBvdGhlciBjYXNlXHJcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2wgPT0gJ2h0dHBzOicpIHtcclxuICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGNvbnRlbnQgbGVuZ3RoIGFuZCBmaXJlIGF3YXlcclxuICB0aGlzLmdldExlbmd0aChmdW5jdGlvbihlcnIsIGxlbmd0aCkge1xyXG4gICAgaWYgKGVyciAmJiBlcnIgIT09ICdVbmtub3duIHN0cmVhbScpIHtcclxuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBjb250ZW50IGxlbmd0aFxyXG4gICAgaWYgKGxlbmd0aCkge1xyXG4gICAgICByZXF1ZXN0LnNldEhlYWRlcignQ29udGVudC1MZW5ndGgnLCBsZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGlwZShyZXF1ZXN0KTtcclxuICAgIGlmIChjYikge1xyXG4gICAgICB2YXIgb25SZXNwb25zZTtcclxuXHJcbiAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uY2UpIHtcclxuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcclxuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2IuY2FsbCh0aGlzLCBlcnJvciwgcmVzcG9uY2UpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgb25SZXNwb25zZSA9IGNhbGxiYWNrLmJpbmQodGhpcywgbnVsbCk7XHJcblxyXG4gICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcclxuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcclxuICAgIH1cclxuICB9LmJpbmQodGhpcykpO1xyXG5cclxuICByZXR1cm4gcmVxdWVzdDtcclxufTtcclxuXHJcbkZvcm1EYXRhLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcclxuICBpZiAoIXRoaXMuZXJyb3IpIHtcclxuICAgIHRoaXMuZXJyb3IgPSBlcnI7XHJcbiAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcclxuICB9XHJcbn07XHJcblxyXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICdbb2JqZWN0IEZvcm1EYXRhXSc7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

eval("// populates missing values\r\nmodule.exports = function(dst, src) {\r\n\r\n  Object.keys(src).forEach(function(prop)\r\n  {\r\n    dst[prop] = dst[prop] || src[prop];\r\n  });\r\n\r\n  return dst;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGV2ZWxvcGVyLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzPzdlMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcG9wdWxhdGVzIG1pc3NpbmcgdmFsdWVzXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZHN0LCBzcmMpIHtcclxuXHJcbiAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApXHJcbiAge1xyXG4gICAgZHN0W3Byb3BdID0gZHN0W3Byb3BdIHx8IHNyY1twcm9wXTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGRzdDtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/form-data/lib/populate.js\n");

/***/ })

};
;